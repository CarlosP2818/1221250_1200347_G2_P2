pipeline {
    agent any

    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: 'Branch a construir')
    }

    environment {
        // Docker Registry Configuration
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_REGISTRY_CREDENTIALS = 'docker-hub-credentials' // ID das tuas credenciais no Jenkins
        DOCKER_IMAGE_NAME = 'lms-authnusers'
        DOCKER_NAMESPACE = 'cralos062' // O teu username do Docker Hub
    }

    stages {
        stage('Checkout') {
            steps {
                // Checkout da branch específica passada pelo orquestrador
                checkout scm
            }
        }

        stage('Build & Unit Tests') {
            steps {
                dir('lms-authnusers') {
                    sh 'mvn clean test'
                }
            }
        }

        stage('Static Analysis & Mutation') {
            parallel {
                stage('SpotBugs') {
                    steps {
                        dir('lms-authnusers') {
                            sh 'mvn com.github.spotbugs:spotbugs-maven-plugin:4.8.6.2:spotbugs'
                        }
                    }
                }
                stage('Pitest') {
                    steps {
                        dir('lms-authnusers') {
                            // Mutation testing pode ser demorado, opcional em cada build
                            sh 'mvn org.pitest:pitest-maven:mutationCoverage'
                        }
                    }
                }
            }
        }

        stage('Package Artifact') {
            steps {
                dir('lms-authnusers') {
                    sh 'mvn package -DskipTests'
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }

        stage('Build & Push Docker Image') {
            steps {
                dir('lms-authnusers') {
                    script {
                        // 1. Logs de Identificação
                        def shortCommit = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                        def buildTag = "${env.BUILD_NUMBER}-${shortCommit}"
                        def imageFullName = "${DOCKER_NAMESPACE}/${DOCKER_IMAGE_NAME}"

                        echo "DEBUG: A preparar build para imagem: ${imageFullName}"
                        echo "DEBUG: Namespace configurado: ${DOCKER_NAMESPACE}"
                        echo "DEBUG: Tag gerada: ${buildTag}"

                        // 2. Build
                        def customImage = docker.build("${imageFullName}:${buildTag}")

                        // 3. Push com logs de autenticação
                        // Importante: Removi o "https://" da URL, o plugin prefere apenas 'index.docker.io/v1/'
                        docker.withRegistry('https://index.docker.io/v1/', DOCKER_REGISTRY_CREDENTIALS) {

                            // Este bloco imprime qual o user que o Jenkins está a carregar das credenciais
                            withCredentials([usernamePassword(credentialsId: DOCKER_REGISTRY_CREDENTIALS,
                                             passwordVariable: 'PASS', usernameVariable: 'USER')]) {
                                echo "DEBUG: A tentar login no Docker Hub com o utilizador: ${USER}"
                                // sh "docker login -u ${USER} -p ${PASS}" // Opcional se o withRegistry falhar
                            }

                            echo "DEBUG: A iniciar push da tag ${buildTag}..."
                            customImage.push()

                            echo "DEBUG: A iniciar push da branch ${params.BRANCH}..."
                            customImage.push(params.BRANCH)

                            echo "DEBUG: A iniciar push da tag latest..."
                            customImage.push("latest")
                        }
                    }
                }
            }
        }

        stage('Deploy to VM (Staging)') {
            steps {
                script {
                    def imageFullName = "${DOCKER_NAMESPACE}/${DOCKER_IMAGE_NAME}"
                    def containerName = "lms-users-app"
                    def hostPort = "30081"
                    def containerPort = "8080" // A porta em que o Spring Boot corre dentro do jar

                    echo "A iniciar deploy do contentor ${containerName}..."

                    // 1. Parar e remover o contentor antigo se ele existir
                    sh "docker rm -f ${containerName} || true"

                    // 2. Limpar imagens antigas (opcional, para poupar espaço na VM)
                    sh "docker image prune -f"

                    // 3. Correr o novo contentor
                    // Usamos a tag 'latest' que acabaste de enviar para o Hub
                    sh """
                        docker run -d \
                        --name ${containerName} \
                        -p ${hostPort}:${containerPort} \
                        --restart unless-stopped \
                        ${imageFullName}:latest
                    """

                    echo "Deploy concluído com sucesso em http://51.13.187.249:${hostPort}"
                }
            }
        }

        stage('Smoke Tests (Staging)') {
            when { expression { params.BRANCH == 'staging' } }
            steps {
                dir('lms-authnusers') {
                    // Ajustado de PowerShell para Shell Linux
                    sh '''
                        export AUTH_URL="http://51.13.187.249:30081/api/public/login"
                        k6 run smoke_test.js
                    '''
                }
            }
        }
    }

    post {
        always {
            // Limpa o workspace para não encher o disco do container
            cleanWs()
        }
        failure {
            echo "O build do serviço ${DOCKER_IMAGE_NAME} falhou!"
        }
    }
}